Ideas:

- Generadores QuickCheck dentro JSON schemas:

Propongo que permitimos que se especifica una funcion erlang como
schema también, con el significado de que es un generador. Tenemos que
pensar en como especificarlo en jason pero el resto es obvio

Propongo añadir un par de keywords: "jsongen" y "jsonval". Sus values
pueden ser el nombre de una función erlang en el formato
"module:function(params)", para jsongen se devuelve un generador de
json y para el caso de jsonval se devuelve una función que devuelve un
boolean.

+ Que hacer con ?LET, y otros macros. Falta sintaxis in eqc.


- All JSON data are JSON schemas:

Proponemos que todos los datos son JSON schemas, son valores 'literales'.
Problema: que hacer con los JSON schemas.
Un objeto es un JSON schema 'tradicional' si contiene un atributo
"schema" : true.
Dentro schemas tradicionales podemos meter valores literales usando
enum (ya se puede), pero, ojo, permitimos que se mete JSON schemas dentro
otra vez usando "schema : true.

- Uniqueness of names in JSON objects

   We need a flag for capturing both semantics:

   Is this valid JSON? { "name": "foo", "name": "bar" }

   It's technically legal, but strongly discouraged, according to the
   RFC (tools.ietf.org/html/rfc4627#section-2.2): "The names within an
   object SHOULD [RECOMMENDED] be unique".

   Two routes:
     Javascript: illegal (and JSON is is supposed to be a subset!)
     Python: overwrite the "bar" entry with the latest value

   Excerpt from: http://stackoverflow.com/questions/7202477/are-double-definitions-allowed-in-json-and-if-so-how-should-they-be-interprete


- Dependencies (mochijson2) must be automatically solved (rebar?).
