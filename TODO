Ideas:

- We should support format (predefined email, uri, etc, recognizers).

- Generadores QuickCheck dentro JSON schemas:

Propongo que permitimos que se especifica una funcion erlang como
schema también, con el significado de que es un generador. Tenemos que
pensar en como especificarlo en jason pero el resto es obvio

Propongo añadir un par de keywords: "jsongen" y "jsonval". Sus values
pueden ser el nombre de una función erlang en el formato
"module:function(params)", para jsongen se devuelve un generador de
json y para el caso de jsonval se devuelve una función que devuelve un
boolean.

+ Que hacer con ?LET, y otros macros. Falta sintaxis in eqc.


- All JSON data are JSON schemas:

Proponemos que todos los datos son JSON schemas, son valores 'literales'.
Problema: que hacer con los JSON schemas.
Un objeto es un JSON schema 'tradicional' si contiene un atributo
"schema" : true.
Dentro schemas tradicionales podemos meter valores literales usando
enum (ya se puede), pero, ojo, permitimos que se mete JSON schemas dentro
otra vez usando "schema : true.

- Uniqueness of names in JSON objects

   We need a flag for capturing both semantics:

   Is this valid JSON? { "name": "foo", "name": "bar" }

   It's technically legal, but strongly discouraged, according to the
   RFC (tools.ietf.org/html/rfc4627#section-2.2): "The names within an
   object SHOULD [RECOMMENDED] be unique".

   Two routes:
     Javascript: illegal (and JSON is is supposed to be a subset!)
     Python: overwrite the "bar" entry with the latest value

   Excerpt from: http://stackoverflow.com/questions/7202477/are-double-definitions-allowed-in-json-and-if-so-how-should-they-be-interprete

- Dependencies (mochijson2) must be automatically solved (rebar?).

- Permit parameters for POST and PUT, in ADDITION to a body.
We probably need a new schema for that (extension of JSON schema).

- How to do things such as support substitution of object values
into query parameters? (i.e., token returned, token used)
Or for that matter in bodies?
One possibility is to extend some kind of substitution syntax for these
entities, e.g., {token} as a literal value inside a schema. 
Maybe we can define: "token" : {"from_resource" : "var"}.
Do we do a deep search? Maybe.
- And a QuickCheck operator:
- "pelle" : {"quickcheck" : "name_of_function"} or
  "pelle" : {"quickcheck" : {name:"..",others}} which
sends along the JSON object to the QuickCheck function name.
- We could do "token" : {"quickcheck" : {name:"resource-var",var-name:"token"}}
(for now that is ok).

- We need to remove links that depend upon an object upon delete,
And change them upon PUT (this obviously depends on the URI, which 
is either linked, or we can link to, the object).

The question is what happens to such indirect things as expressed above,
i.e., permitting the {key} syntax in schema:s and querySchema:s,
when we start delete the object defining the key upon which they rely.
(I guess they should be deleted too, so we have a depends-on relation
for links, this can obviously be transitive).

- We should have convenient operations for defining frequencies,
and for redefining values.

- Maybe define a whole schema using quickcheck
(i.e., define querySchema or schema).













